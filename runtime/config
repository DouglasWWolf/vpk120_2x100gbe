export axi_uart_device=/dev/ttyUSB2

                     DCMAC=0xA4000000
               GLOBAL_MODE=0x0004
         GLOBAL_CONTROL_RX=0x00F0
         GLOBAL_CONTROL_TX=0x00F8
      C0_CHANNEL_CONFIG_TX=0x1000
      C0_CHANNEL_CONFIG_RX=0x1004
     C0_CHANNEL_CONTROL_RX=0x1030
     C0_CHANNEL_CONTROL_TX=0x1038
                C0_TX_MODE=0x1040
                C0_RX_MODE=0x1044
        C0_PORT_CONTROL_RX=0x10F0
        C0_PORT_CONTROL_TX=0x10F8
C0_STAT_PORT_RX_PHY_STATUS=0x1C00           


              DCMAC_CTL=0xA4100000
     DCMAC_CTL_LOOPBACK=$((DCMAC_CTL + 0*4))
    DCMAC_CTL_RESET_ALL=$((DCMAC_CTL + 1*4))
    DCMAC_CTL_RESET_RX0=$((DCMAC_CTL + 2*4))    
    DCMAC_CTL_RESET_RX1=$((DCMAC_CTL + 3*4))    
DCMAC_CTL_RX_RESET_DONE=$((DCMAC_CTL + 4*4))    
DCMAC_CTL_TX_RESET_DONE=$((DCMAC_CTL + 5*4))    

axi()
{
    axireg $1 $2 $3 $4
}


all_ports()
{
     for i in {0..5}; do 
         addr=$((DCMAC + $1 + (i*4096)))
         axi $addr $2
     done
}


wait_gt_txresetdone()
{
    sleep .1
    v=$(axi -dec $DCMAC_CTL_TX_RESET_DONE)
    if [ $v -ne 3 ]; then
        echo wait_gt_txresetdone failed!
        read
        exit 1
    fi
}


wait_gt_rxresetdone()
{
    sleep .1
    v=$(axi -dec $DCMAC_CTL_RX_RESET_DONE)
    if [ $v -ne 3 ]; then
        echo wait_gt_rxresetdone failed!
        read
        exit 1
    fi
}



assert_all_reset()
{
    axi $((DCMAC + GLOBAL_CONTROL_RX)) 7
    axi $((DCMAC + GLOBAL_CONTROL_TX)) 7 
    all_ports $C0_PORT_CONTROL_TX 3
    all_ports $C0_PORT_CONTROL_RX 3
}

release_all_reset()
{
    axi $((DCMAC + GLOBAL_CONTROL_RX)) 0
    axi $((DCMAC + GLOBAL_CONTROL_TX)) 0 
    all_ports $C0_PORT_CONTROL_TX 0
    all_ports $C0_PORT_CONTROL_RX 0
}



# Should per port that is in use
assert_channel_resets()
{
    for i in {0..3}; do
        axi $((DCMAC + C0_CHANNEL_CONTROL_RX + i*4096)) 1
        axi $((DCMAC + C0_CHANNEL_CONTROL_TX + i*4096)) 1 
        sleep .01
        axi $((DCMAC + C0_PORT_CONTROL_RX + i*4096)) 3
        axi $((DCMAC + C0_PORT_CONTROL_TX + i*4096)) 3 
        sleep .01
    done
}

release_channel_resets()
{
    for i in {0..3}; do
        axi $((DCMAC + C0_CHANNEL_CONTROL_RX + i*4096)) 0
        axi $((DCMAC + C0_CHANNEL_CONTROL_TX + i*4096)) 0 
        sleep .01
        axi $((DCMAC + C0_PORT_CONTROL_RX + i*4096)) 0
        axi $((DCMAC + C0_PORT_CONTROL_TX + i*4096)) 0 
        sleep .01
    done
}


config_mac()
{
    all_ports $C0_CHANNEL_CONFIG_RX 0x25800062
    all_ports $C0_CHANNEL_CONFIG_TX 0xC01
}


set_data_rate()
{
    wdata_tx=$(( (5 * 2**16) | (1 * 2**4 ) ))
    wdata_rx=$(( (5 * 2**16) | (1 * 2**11) ))
    all_ports $C0_TX_MODE $wdata_tx
    all_ports $C0_RX_MODE $wdata_rx
}


# Call "align 0" or "align 1"
align()
{ 
    port=$1
    if [ $port -eq 0 ]; then
        rxdp_reset=$DCMAC_CTL_RESET_RX0
        control_port_a=$((DCMAC + C0_PORT_CONTROL_RX         + 0*4096))
        control_port_b=$((DCMAC + C0_PORT_CONTROL_RX         + 0*4096))
            phy_status=$((DCMAC + C0_STAT_PORT_RX_PHY_STATUS + 0*4096))
       reset_done_mask=1
    else
        rxdp_reset=$DCMAC_CTL_RESET_RX1
        control_port_a=$((DCMAC + C0_PORT_CONTROL_RX         + 1*4096))
        control_port_b=$((DCMAC + C0_PORT_CONTROL_RX         + 1*4096))
            phy_status=$((DCMAC + C0_STAT_PORT_RX_PHY_STATUS + 1*4096))
       reset_done_mask=2            
    fi

    for i in {1..10}; do

        # Reset the RX datapath
        axi $rxdp_reset 1
        sleep .1
        axi $rxdp_reset 0
        sleep .1

        # Wait for reset to complete
        v=$(axi -dec $DCMAC_CTL_RX_RESET_DONE)
        if [ $((v & reset_done_mask)) -ne $reset_done_mask ]; then
            echo wait_gt_rxresetdone failed!
            read
            exit 1
        fi

        # Reset the specified MAC port via the DCMAC
        axi $control_port_a 2
        axi $control_port_b 2
        sleep .1
        axi $control_port_a 0
        axi $control_port_b 0
        sleep .1

        # Wait for alignment
        axi $phy_status 0xFFFFFFFF
        v=$(axi -dec $phy_status)
        printf "Port $port PHY Status = 0x%X\n" $v
        test $((v & 1)) -eq 1 && return

    done
}



initial_configure()
{
    #  Near-end PCS loopback
    axi $DCMAC_CTL_LOOPBACK 0

    axi $DCMAC_CTL_RESET_ALL 1
    sleep .01
    axi $DCMAC_CTL_RESET_ALL 0
    sleep .01

    wait_gt_txresetdone
    wait_gt_rxresetdone

    assert_all_reset
    assert_channel_resets    
    
    axi $((DCMAC + GLOBAL_MODE)) 0x07550000
    config_mac
    set_data_rate

    release_all_reset
    release_channel_resets    
}


echo $0 | grep -q "align"
if [ $? -ne 0 ]; then
    initial_configure
    exit
fi

if [ "$1" == "0" ] || [ "$1" == "1" ]; then
    align $1
else
    echo "Must specify \"align 0\" or \"align 1\""
fi

